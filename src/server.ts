// --- src/server.ts ---
import express, { Request, Response } from 'express';
import formidable, { File, Fields } from 'formidable';
import dotenv from 'dotenv';
import { transcribeAudio, progressEmitter } from './whisper.js';
import path from 'path';
import { promises as fs } from 'fs';
import http from 'http';
import { Server } from 'socket.io';
import { fileURLToPath } from 'url';
import { spawn } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config();
const app = express();
const server = http.createServer(app);
const io = new Server(server);
const port = process.env.PORT || 3001;

// Middleware pour servir les fichiers statiques
app.use(express.static(path.join(__dirname, '../public')));

// Route pour la transcription
app.post('/transcribe', async (req: Request, res: Response) => {
  console.log(`üîΩ R√©ception d'une demande de transcription de fichier`);
  const uploadDir = path.join(__dirname, '../uploads');
  
  // Cr√©er le dossier uploads s'il n'existe pas
  try {
    await fs.access(uploadDir);
  } catch {
    console.log(`üìÅ Cr√©ation du dossier uploads`);
    await fs.mkdir(uploadDir, { recursive: true });
  }

  console.log(`‚è≥ Configuration de formidable...`);
  const form = formidable({ 
    multiples: false,
    uploadDir,
    keepExtensions: true,
    maxFileSize: 100 * 1024 * 1024 // Augmenter √† 100 MB
  });

  console.log(`‚è≥ Traitement du formulaire en cours...`);
  form.parse(req, async (err: Error | null, fields: Fields, files: formidable.Files) => {
    if (err) {
      console.error('‚ùå Erreur lors de l\'upload:', err);
      return res.status(500).json({ error: 'Erreur lors de l\'upload: ' + err.message });
    }

    console.log(`üì¶ Contenu de files:`, Object.keys(files));
    console.log(`üì¶ Contenu de fields:`, Object.keys(fields));

    const audioFiles = files.audio;
    if (!audioFiles) {
      console.error('‚ùå Fichier audio manquant');
      return res.status(400).json({ error: 'Fichier audio manquant' });
    }

    // G√©rer le cas o√π audioFiles est un tableau (multiple=true)
    let audioFile: File;
    if (Array.isArray(audioFiles)) {
      console.log(`‚ÑπÔ∏è Plusieurs fichiers audio re√ßus, utilisation du premier`);
      if (audioFiles.length === 0) {
        console.error('‚ùå Aucun fichier audio re√ßu dans le tableau');
        return res.status(400).json({ error: 'Aucun fichier audio re√ßu' });
      }
      audioFile = audioFiles[0] as unknown as File;
    } else {
      audioFile = audioFiles as unknown as File;
    }

    if (!audioFile.filepath) {
      console.error('‚ùå Fichier audio sans chemin');
      return res.status(400).json({ error: 'Fichier audio invalide: pas de chemin' });
    }

    try {
      // V√©rifier que le fichier existe
      try {
        await fs.access(audioFile.filepath);
        console.log(`‚úÖ Fichier accessible: ${audioFile.filepath}`);
      } catch (e) {
        console.error(`‚ùå Impossible d'acc√©der au fichier: ${audioFile.filepath}`, e);
        return res.status(500).json({ error: 'Fichier inaccessible apr√®s upload' });
      }

      console.log(`üìÑ Fichier re√ßu: ${audioFile.filepath}`);
      console.log(`üî§ Type de fichier: ${audioFile.mimetype}`);
      console.log(`üìè Taille du fichier: ${audioFile.size} octets`);

      // V√©rifier que le fichier a une taille non nulle
      if (audioFile.size === 0) {
        console.error('‚ùå Fichier vide');
        return res.status(400).json({ error: 'Le fichier audio est vide' });
      }

      console.log(`üîÑ D√©but du traitement du fichier`);

      // Traiter le fichier MP3 si n√©cessaire
      let fileToTranscribe = audioFile.filepath;
      
      const generateSrt = fields.generateSrt?.[0] === 'true';
      console.log(`üî§ Option de g√©n√©ration SRT: ${generateSrt ? 'Oui' : 'Non'}`);
      
      // Choisir le mod√®le en fonction de l'extension du fichier
      // Pour les MP3, utiliser un mod√®le plus petit et plus rapide
      let model: 'tiny' | 'base' | 'small' | 'medium' | 'large' = 'base';
      
      if (audioFile.filepath.toLowerCase().endsWith('.mp3')) {
        console.log(`üìä Fichier MP3 d√©tect√©, utilisation du mod√®le 'tiny' pour plus de rapidit√©`);
        model = 'tiny';
      } else {
        const requestedModel = fields.model?.[0] as 'tiny' | 'base' | 'small' | 'medium' | 'large';
        if (requestedModel && ['tiny', 'base', 'small', 'medium', 'large'].includes(requestedModel)) {
          model = requestedModel;
          console.log(`üìä Mod√®le sp√©cifi√© par l'utilisateur: '${model}'`);
        } else {
          console.log(`üìä Mod√®le par d√©faut utilis√©: '${model}'`);
        }
      }
      
      console.log(`üéØ Lancement de la transcription avec Whisper...`);
      const result = await transcribeAudio(fileToTranscribe, generateSrt, model);
      
      console.log(`‚úÖ Transcription r√©ussie! Longueur du texte: ${result.text?.length || 0} caract√®res`);
      
      // Envoyer le r√©sultat au client sous forme de JSON standard
      res.json(result);
      
      // Nettoyer le fichier temporaire apr√®s la transcription
      try {
        await fs.unlink(audioFile.filepath);
        console.log(`üßπ Fichier temporaire supprim√©: ${audioFile.filepath}`);
      } catch (error) {
        console.error('‚ùå Erreur lors de la suppression du fichier temporaire:', error);
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la transcription:', error);
      
      // Envoyer l'erreur au client
      res.status(500).json({ 
        error: error instanceof Error ? error.message : 'Erreur pendant la transcription' 
      });
      
      // Nettoyer le fichier temporaire en cas d'erreur
      try {
        if (audioFile.filepath) {
          await fs.unlink(audioFile.filepath);
          console.log(`üßπ Fichier temporaire supprim√© apr√®s erreur: ${audioFile.filepath}`);
        }
      } catch (unlinkError) {
        console.error('‚ùå Erreur lors de la suppression du fichier temporaire:', unlinkError);
      }
    }
  });
});

// Gestion des connexions WebSocket
io.on('connection', (socket) => {
  console.log(`üë§ Nouvelle connexion client (ID: ${socket.id})`);

  // Variables pour suivre le processus Python actif pour ce client
  let activeProcess: number | null = null;

  // √âcouter les √©v√©nements de progression
  const progressHandler = (data: { progress: number }) => {
    console.log(`üìä Progression du mod√®le: ${Math.round(data.progress * 100)}%`);
    socket.emit('modelLoadingProgress', data);
  };

  progressEmitter.on('modelLoadingProgress', progressHandler);

  socket.on('startRecording', () => {
    console.log(`üéôÔ∏è D√©marrage de l'enregistrement (client: ${socket.id})`);
  });

  socket.on('cancelTranscription', () => {
    console.log(`üõë Annulation de la transcription demand√©e (client: ${socket.id})`);
    if (activeProcess) {
      try {
        process.kill(activeProcess);
        console.log(`‚úÖ Processus Python arr√™t√© (PID: ${activeProcess})`);
      } catch (error) {
        console.error(`‚ùå Erreur lors de l'arr√™t du processus (PID: ${activeProcess}):`, error);
      }
      activeProcess = null;
    }
  });

  socket.on('audioData', async (audioData) => {
    try {
      const tempFilePath = path.join(__dirname, '../uploads', `temp-${Date.now()}.wav`);
      console.log(`üíæ R√©ception de donn√©es audio (client: ${socket.id})`);
      console.log(`üìù √âcriture du fichier temporaire: ${tempFilePath}`);
      
      // V√©rifier que les donn√©es sont soit un Buffer soit un ArrayBuffer
      let audioBuffer;
      if (audioData instanceof ArrayBuffer) {
        audioBuffer = Buffer.from(audioData);
      } else if (Buffer.isBuffer(audioData)) {
        audioBuffer = audioData;
      } else {
        audioBuffer = Buffer.from(audioData);
      }
      
      console.log(`üìä Taille des donn√©es audio re√ßues: ${audioBuffer.length} octets`);
      
      // V√©rifier la pr√©sence de l'en-t√™te RIFF
      const hasRiffHeader = audioBuffer.length >= 44 && 
                            audioBuffer.slice(0, 4).toString() === 'RIFF' && 
                            audioBuffer.slice(8, 12).toString() === 'WAVE';
      
      if (!hasRiffHeader) {
        console.warn("‚ö†Ô∏è Avertissement: L'audio ne contient pas d'en-t√™te RIFF valide");
      } else {
        console.log("‚úÖ En-t√™te RIFF d√©tect√© dans les donn√©es audio");
      }
      
      await fs.writeFile(tempFilePath, audioBuffer);
      console.log(`‚úÖ Fichier temporaire cr√©√© et accessible: ${tempFilePath}`);

      console.log(`üéØ D√©marrage de la transcription...`);
      
      // Surveiller le processus Python pour pouvoir l'arr√™ter
      const processStartHandler = (pid: number) => {
        activeProcess = pid;
        console.log(`üìã Processus Python assign√© au client ${socket.id} (PID: ${pid})`);
      };
      
      progressEmitter.once('processStarted', processStartHandler);
      
      // Utiliser le mod√®le tiny pour l'enregistrement en direct (plus rapide)
      const model = 'tiny'; // Plus l√©ger et plus rapide pour le direct
      console.log(`üìä Utilisation du mod√®le '${model}' pour l'enregistrement en direct`);
      
      const result = await transcribeAudio(tempFilePath, false, model);
      
      // Nettoyage
      activeProcess = null;
      progressEmitter.off('processStarted', processStartHandler);
      
      console.log(`‚úÖ Transcription r√©ussie! Longueur du texte: ${result.text?.length || 0} caract√®res`);
      
      if (result.text) {
        socket.emit('transcription', { text: result.text });
        console.log(`üì§ R√©sultat envoy√© au client: "${result.text.substring(0, 50)}${result.text.length > 50 ? '...' : ''}"`);
      } else {
        console.log(`‚ö†Ô∏è Aucun texte de transcription re√ßu`);
        socket.emit('error', 'Aucun texte de transcription re√ßu');
      }
      
      await fs.unlink(tempFilePath);
      console.log(`üßπ Fichier temporaire supprim√©: ${tempFilePath}`);
    } catch (error: any) {
      activeProcess = null;
      console.error(`‚ùå Erreur lors de la transcription en direct:`, error);
      socket.emit('error', error?.message || 'Erreur lors de la transcription');
    }
  });

  socket.on('rawAudioData', async (audioData) => {
    try {
      console.log(`üíæ R√©ception de donn√©es audio brutes (client: ${socket.id})`);
      
      // Cr√©er un nom de fichier temporaire unique avec l'extension appropri√©e
      const tempFilePath = path.join(__dirname, '../uploads', `temp-${Date.now()}.webm`);
      console.log(`üìù √âcriture du fichier temporaire WEBM: ${tempFilePath}`);
      
      // Conversion en Buffer si n√©cessaire
      let audioBuffer;
      if (audioData instanceof ArrayBuffer) {
        audioBuffer = Buffer.from(audioData);
      } else if (Buffer.isBuffer(audioData)) {
        audioBuffer = audioData;
      } else {
        audioBuffer = Buffer.from(audioData);
      }
      
      console.log(`üìä Taille des donn√©es audio re√ßues: ${audioBuffer.length} octets`);
      
      // √âcrire le fichier webm directement
      await fs.writeFile(tempFilePath, audioBuffer);
      console.log(`‚úÖ Fichier WEBM cr√©√©: ${tempFilePath}`);
      
      // Surveiller le processus Python pour pouvoir l'arr√™ter
      const processStartHandler = (pid: number) => {
        activeProcess = pid;
        console.log(`üìã Processus Python assign√© au client ${socket.id} (PID: ${pid})`);
      };
      
      progressEmitter.once('processStarted', processStartHandler);
      
      // Utiliser le mod√®le tiny pour l'enregistrement en direct
      const model = 'tiny';
      console.log(`üìä Utilisation du mod√®le '${model}' pour l'enregistrement en direct`);
      
      // Transcription directe du fichier webm
      const result = await transcribeAudio(tempFilePath, false, model);
      
      // Nettoyage
      activeProcess = null;
      progressEmitter.off('processStarted', processStartHandler);
      
      console.log(`‚úÖ Transcription r√©ussie! Longueur du texte: ${result.text?.length || 0} caract√®res`);
      
      if (result.text) {
        socket.emit('transcription', { text: result.text });
        console.log(`üì§ R√©sultat envoy√© au client: "${result.text.substring(0, 50)}${result.text.length > 50 ? '...' : ''}"`);
      } else {
        console.log(`‚ö†Ô∏è Aucun texte de transcription re√ßu`);
        socket.emit('error', 'Aucun texte de transcription re√ßu');
      }
      
      // Nettoyer le fichier temporaire
      await fs.unlink(tempFilePath);
      console.log(`üßπ Fichier temporaire supprim√©: ${tempFilePath}`);
      
    } catch (error: any) {
      activeProcess = null;
      console.error(`‚ùå Erreur lors de la transcription en direct:`, error);
      socket.emit('error', error?.message || 'Erreur lors de la transcription');
    }
  });

  socket.on('stopRecording', () => {
    console.log(`‚èπÔ∏è Arr√™t de l'enregistrement (client: ${socket.id})`);
  });

  socket.on('disconnect', () => {
    console.log(`üëã D√©connexion client (ID: ${socket.id})`);
    // Nettoyer l'√©couteur d'√©v√©nements lors de la d√©connexion
    progressEmitter.off('modelLoadingProgress', progressHandler);
    
    // Arr√™ter le processus en cours si le client se d√©connecte
    if (activeProcess) {
      try {
        process.kill(activeProcess);
        console.log(`‚úÖ Processus Python arr√™t√© apr√®s d√©connexion (PID: ${activeProcess})`);
      } catch (error) {
        console.error(`‚ùå Erreur lors de l'arr√™t du processus:`, error);
      }
      activeProcess = null;
    }
  });
});

// D√©marrage du serveur
server.listen(port, () => {
  console.log(`‚ú® Serveur lanc√© sur http://localhost:${port}`);
  console.log(`üìä Interface disponible √† cette adresse`);
  console.log(`üí° En attente d'activit√©...`);
  console.log(`‚ÑπÔ∏è Les logs suivants montreront les actions des utilisateurs`);
  console.log(`------------------------------------------`);
});

// Ajouter une v√©rification p√©riodique d'activit√©
setInterval(() => {
  console.log(`üíì Serveur actif - ${new Date().toLocaleTimeString()} - En attente d'activit√©...`);
}, 60000); // Afficher un message toutes les minutes